## js 原理

### 函数执行栈

执行栈，在其他编程语言中也被叫做**调用栈**，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。

当 JavaScript 引擎首次读取你的脚本时，它会创建一个全局执行上下文并将其推入当前的执行栈。每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端。

引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出，上下文控制权将移到当前执行栈的下一个执行上下文。



### 执行上下文

执行上下文可以理解为当前代码的执行环境，JavaScript中的运行环境大概包括三种情况。

* 全局环境：JavaScript代码运行起来会首先进入该环境
* 函数环境：当函数被调用执行时，会进入当前函数中执行代码
* eval（不建议使用，可忽略）

当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。

**创建阶段**

* 执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。

**执行阶段**

* 完成变量赋值，函数引用，以及执行其他代码，然后等待被回收

### 变量对象（Variable Object）

变量对象的创建，依次经历了以下几个过程：

* 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。
* 检查当前上下文的函数声明，在变量对象中以函数名建立一个属性，属性值为该函数的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。
* 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。（即函数声明优先级大过变量声明）

全局上下文的变量对象：window

### 作用域 && 作用域链

作用域：

* 在JavaScript中，我们可以将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。
* JavaScript中只有全局作用域与函数作用域（这里不讨论eval和块级作用域）
* 作用域与执行上下文是完全不同的两个概念，但是一定要仔细区分。


> JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段*作用域*规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，*执行上下文*在这个阶段创建。

作用域链：

* 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。
* 很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道是更加贴切的形容，所有的最末端都为全局变量对象。

### this

* 函数调用时确定
* 注意区分函数的是**独立运行**还是被**调用者调用**
* 因为 this 是在执行上下文中确定的，因此，确定 this 还有一个技巧，那就是观察函数执行时所在的上下文
 





















